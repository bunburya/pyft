import os
from datetime import datetime, timedelta
from typing import Optional, Callable, Tuple, Generator, Dict, Union, List

import fitdecode
import lxml.etree
import numpy as np
import pandas as pd
import pytz
import dateutil.parser as dp
import gpxpy
from gpxpy import gpx
from pyft.config import Config
from pyft.geo_utils import haversine_distance
import logging

# logging.getLogger().setLevel(logging.INFO)

MILE = 1609.344  # metres in a mile


# Error definitions

class PyftParserException(Exception): pass
class GPXParserError(PyftParserException): pass
class TCXParserError(PyftParserException): pass
class FITParserError(PyftParserException): pass


# TODO: Move activity type definitions to a different file.
# Also, make comprehensive, or at least give Pyft a way to "learn" from users manually setting type where
# activity type is not recognised.

class GarminMixin:
    """Data and methods used to parse files generated by Garmin."""

    GARMIN_TYPES = {
        'hiking': 'hike',
        'running': 'run',
        'walking': 'walk'
    }


class StravaMixin:
    """Data and methods used to parse files generated by Strava."""

    STRAVA_TYPES = {
        '4': 'hike',
        '9': 'run',
        '10': 'walk',
    }


class BaseParser:
    ACTIVITY_TYPES = {'run', 'walk', 'hike'}

    # The DataFrame that is passed to infer_points_data must contain all of these columns
    INITIAL_COL_NAMES_POINTS = (
        'point_no', 'track_no', 'segment_no',
        'latitude', 'longitude', 'elevation',
        'time', 'hr', 'cadence', 'lap', 'speed'
    )

    INITIAL_COL_NAMES_LAPS = (
        'lap_no', 'start_time', 'distance', 'duration', 'calories'
    )

    def __init__(self, fpath: str, config: Config):
        logging.debug(f'Parsing {fpath} using {type(self).__name__}.')
        self.config = config
        self._parse(fpath)

    def convert_speed(self, meters_per_sec: Optional[Union[float, pd.Series]]) -> Optional[Union[float, pd.Series]]:
        """Converts meters/second to km/hour."""
        if meters_per_sec is not None:
            return meters_per_sec * 3.6
        else:
            return None

    def infer_points_data(self, df: pd.DataFrame) -> Optional[pd.DataFrame]:
        if missing := set(self.INITIAL_COL_NAMES_POINTS).difference(df.columns):
            raise ValueError(f'DataFrame is missing the following columns: {missing}.')
        df = df.copy()
        prev_lat = df['latitude'].shift()
        prev_lon = df['longitude'].shift()
        df['step_length_2d'] = self.distance_2d(df['latitude'], df['longitude'], prev_lat, prev_lon)
        df['cumul_distance_2d'] = df['step_length_2d'].fillna(0).cumsum()
        df['km'] = (df['cumul_distance_2d'] // 1000).astype(int)
        df['mile'] = (df['cumul_distance_2d'] // MILE).astype(int)
        df['run_time'] = df['time'] - df.iloc[0]['time']
        logging.debug(f'Average step length (distance): {df["step_length_2d"].mean()}')
        # step_time = df['time'] - df['time'].shift()
        # logging.info(f'Average step length (time): {step_time.mean()}s')

        # Calculate speed / pace.
        # If we have speed from the device, calculate the other metrics from that.
        # Otherwise, calculate the metrics from the time and location data.
        if df['kmph'].isnull():
            prev_time = df['time'].shift(self.config.speed_measure_interval)
            prev_cumul_distance = df['cumul_distance_2d'].shift(self.config.speed_measure_interval)
            interval_distance = df['cumul_distance_2d'] - prev_cumul_distance
            interval_time = df['time'] - prev_time
            df['kmph'] = self.convert_speed(interval_distance / interval_time)

        #df['km_pace'] = (1000 / interval_distance) * (interval_time)
        #df['mile_pace'] = (MILE / df['step_length_2d']) * (df['time'] - prev_time)
        #df['kmph'] = (3600 / df['km_pace'].dt.total_seconds())
        #df['mph'] = df['kmph'] / (MILE / 1000)

        df['mph'] = (1000 * df['kmph']) / MILE
        df['km_pace'] = 3600 / df['kmph']
        df['mile_pace'] = 3600 / df['mph']

        return df

    def distance_2d(self, lat1: pd.Series, lon1: pd.Series, lat2: pd.Series, lon2: pd.Series) -> np.ndarray:
        return haversine_distance(lat1, lon1, lat2, lon2)

    def _parse(self, fpath: str):
        raise NotImplementedError('Child of BaseParser must implement a _parse method.')

    @property
    def points(self) -> pd.DataFrame:
        """Return a DataFrame with limited information on points (as
        described in INITIAL_COL_NAMES_POINTS). The infer_points_data can be
        called on the resulting DataFrame to generate more data.
        """
        raise NotImplementedError('Child of BaseParser must implement a points property.')

    @property
    def laps(self) -> Optional[pd.DataFrame]:
        """Return a DataFrame with limited information on laps (as
        described in INITIAL_COL_NAMES_LAPS), if available (or None
        otherwise).

        Return None by default.
        """
        return None

    @property
    def date_time(self) -> datetime:
        raise NotImplementedError('Child of BaseParser must implement a date_time property.')

    @property
    def metadata(self) -> dict:
        raise NotImplementedError('Child of BaseParser must implement a metadata property.')

    @property
    def activity_type(self) -> str:
        raise NotImplementedError('Child of BaseParser must implement an activity_type property.')


class GPXParser(BaseParser, GarminMixin, StravaMixin):
    # Namespaces for extensions
    # (Even though these relate to Garmin we do not put them in the GarminMixin class because they are also
    # used by Strava-generated GPX files.)
    NAMESPACES = {'garmin_tpe': 'http://www.garmin.com/xmlschemas/TrackPointExtension/v1'}

    def __init__(self, *args, **kwargs):
        self._points_df = None
        super().__init__(*args, **kwargs)

    def _parse(self, fpath: str):
        with open(fpath) as f:
            self.gpx = gpxpy.parse(f)

    def _get_try_func(self, func: Callable[[gpx.GPXTrackPoint, gpx.GPXTrackPoint], float]) \
            -> Callable[[gpx.GPXTrackPoint, gpx.GPXTrackPoint], Optional[float]]:
        def _try_func(p1: gpx.GPXTrackPoint, p2: gpx.GPXTrackPoint) -> Optional[float]:
            try:
                return func(p1, p2)
            except AttributeError:
                return np.nan

        return _try_func

    def _get_hr(self, elem: lxml.etree._Element) -> Optional[int]:
        try:
            return int(elem.find('garmin_tpe:hr', self.NAMESPACES).text)
        except AttributeError:
            # "text" attribute not found, so presumably None
            return None

    def _get_cad(self, elem: lxml.etree._Element) -> Optional[int]:
        try:
            return int(elem.find('garmin_tpe:cad', self.NAMESPACES).text)
        except AttributeError:
            return None

    def _get_garmin_tpe(self, point: gpx.GPXTrackPoint) -> lxml.etree._Element:
        for ext in point.extensions:
            if ext.tag.startswith(f'{{{self.NAMESPACES["garmin_tpe"]}}}'):
                return ext

    def _iter_points(self) -> Generator[Tuple[
                                            int,
                                            int,
                                            int,
                                            float,
                                            float,
                                            Optional[float],
                                            datetime,
                                            Optional[int],
                                            Optional[int],
                                            None
                                        ], None, None]:
        for point, track_no, segment_no, point_no in self.gpx.walk():
            ext = self._get_garmin_tpe(point)
            hr = self._get_hr(ext)
            cad = self._get_cad(ext)

            # Convert tz from "SimpleTZ" used by gpxpy)
            time = point.time.replace(tzinfo=pytz.FixedOffset(point.time.tzinfo.offset))
            yield (
                point_no, track_no, segment_no,
                point.latitude, point.longitude, point.elevation,
                time, hr, cad, None  # None = lap (GPX data doesn't have laps)
            )

    @property
    def points(self) -> pd.DataFrame:
        """Return a DataFrame with limited information on points (as
        described in INITIAL_COL_NAMES_POINTS). The infer_points_data
        method can be called on the resulting DataFrame to generate
        more data.
        """
        if self._points_df is None:
            df = pd.DataFrame(self._iter_points(), columns=self.INITIAL_COL_NAMES_POINTS)
            self._points_df = self.infer_points_data(df)
        return self._points_df

    @property
    def date_time(self) -> datetime:
        try:
            return self.gpx.time.replace(tzinfo=pytz.FixedOffset(self.gpx.time.tzinfo.offset))
        except AttributeError:
            return self.gpx.time

    @property
    def metadata(self) -> dict:
        """Return (selected) metadata for GPX object."""
        return {
            'name': self.gpx.name,
            'description': self.gpx.description,
            'date_time': self.date_time,
            'activity_type': self.activity_type
        }

    @property
    def activity_type(self) -> str:
        activity_type = 'unknown'
        track_type = self.gpx.tracks[0].type
        if track_type in self.ACTIVITY_TYPES:
            activity_type = track_type
        elif self.gpx.creator.startswith('StravaGPX'):
            activity_type = self.STRAVA_TYPES.get(track_type, activity_type)
        elif self.gpx.creator.startswith('Garmin Connect'):
            activity_type = self.GARMIN_TYPES.get(track_type, activity_type)
        return activity_type


class BaseActivityParser(BaseParser):

    """A base class for parsers that parse files describing an activity
    (such as TCX and FIT files), rather than simply GPS data (such as
    GPX files). Contains additional methods for parsing and converting
    additional data generally not found in GPX files.
    """

    def __init__(self, *args, **kwargs):
        self._backfill = []
        self._lap = 1
        self._point = 0
        super().__init__(*args, **kwargs)

    def _get_lap_no(self) -> int:
        lap = self._lap
        self._lap += 1
        return lap

    def _get_point_no(self) -> int:
        point = self._lap
        self._point += 1
        return point

    def handle_backfill(self, point_data: dict, all_points_data: List[dict],
                        lat: Optional[float], lon: Optional[float]):
        # Sometimes, a file will report elevation without reporting lat/lon data. In this case, we store
        # whatever data we find, and once we subsequently receive lat/lon data we "backfill" the missing data with that.
        if (lat is None) or (lon is None):
            self._backfill.append(point_data)
        else:
            if self._backfill:
                for to_add in self._backfill:
                    for k in point_data:
                        if (to_add[k] is None) and (point_data[k] is not None):
                            to_add[k] = point_data[k]
                    all_points_data.append(to_add)
                self._backfill = []
            all_points_data.append(point_data)


class TCXParser(BaseActivityParser, GarminMixin, StravaMixin):
    NAMESPACES = {
        'ns': 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2',
        'user_ns': 'http://www.garmin.com/xmlschemas/UserProfile/v2',
        'activity_ns': 'http://www.garmin.com/xmlschemas/ActivityExtension/v2',
        'profile_ns': 'http://www.garmin.com/xmlschemas/ProfileExtension/v1',
        'goals_ns': 'http://www.garmin.com/xmlschemas/ActivityGoals/v1'
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _parse(self, fpath: str):
        self.xml_root = lxml.etree.parse(fpath).getroot()
        self.activity = self.xml_root.find('ns:Activities', self.NAMESPACES)[0]

    def _iter_laps(self, activity_elem: lxml.etree._Element):
        """Iterate through an Activity element and handle each Lap."""
        laps_data = []
        points_data = []
        for lap in activity_elem.findall('ns:Lap', self.NAMESPACES):
            lap_no = self._get_lap_no()
            lap_data = {'lap_no': lap_no}
            if 'StartTime' in lap.attrib:
                lap_data['start_time'] = dp.parse(lap.attrib['StartTime'])
            if (dist_elem := lap.find('ns:DistanceMeters', self.NAMESPACES)) is not None:
                lap_data['distance'] = float(dist_elem.text)
            if (time_elem := lap.find('ns:TotalTimeSeconds', self.NAMESPACES)) is not None:
                lap_data['duration'] = timedelta(seconds=float(time_elem.text))
            if (cal_elem := lap.find('ns:Calories', self.NAMESPACES)) is not None:
                lap_data['calories'] = float(cal_elem.text)
            laps_data.append(lap_data)
            self._iter_points(lap, points_data, lap_no)
        self._laps_df = pd.DataFrame(laps_data, columns=self.INITIAL_COL_NAMES_LAPS)
        self._points_df = self.infer_points_data(pd.DataFrame(points_data, columns=self.INITIAL_COL_NAMES_POINTS))

    def _iter_points(self, lap_elem: lxml.etree._Element, points_data: List[dict], lap_no: int):
        track = lap_elem.find('ns:Track', self.NAMESPACES)
        data = {
            'lap': lap_no,
            'track_no': 0,
            'segment_no': 0,
            'point_no': self._get_point_no()
        }
        for point_elem in track.findall('ns:Trackpoint', self.NAMESPACES):
            lat = lon = None
            if (position_elem := point_elem.find('ns:Position', self.NAMESPACES)) is not None:
                if (lat_elem := position_elem.find('ns:LatitudeDegrees', self.NAMESPACES)) is not None:
                    lat = float(lat_elem.text)
                if (lon_elem := position_elem.find('ns:LongitudeDegrees', self.NAMESPACES)) is not None:
                    lon = float(lon_elem.text)

            if (time_elem := point_elem.find('ns:Time', self.NAMESPACES)) is not None:
                data['time'] = dp.parse(time_elem.text)
            if (elev_elem := point_elem.find('ns:AltitudeMeters', self.NAMESPACES)) is not None:
                data['elevation'] = float(elev_elem.text)
            if (hr_elem := point_elem.find('ns:HeartRateBpm', self.NAMESPACES)) is not None:
                data['hr'] = float(hr_elem.text)
            if (cad_elem := point_elem.find('ns:Cadence', self.NAMESPACES)) is not None:
                data['cadence'] = float(cad_elem.text)
            if (speed_elem := point_elem.find('.//ns:Speed')) is not None:
                data['kmph'] = self.convert_speed(float(speed_elem.text))

            self.handle_backfill(data, points_data, lat, lon)


class FITParser(BaseActivityParser, GarminMixin):
    MANDATORY_POINT_FIELDS = (
        'position_lat',
        'position_long',
        'timestamp'
    )

    OPTIONAL_POINT_FIELDS = (
        'altitude',
        'heart_rate',
        'cadence'
    )

    MANDATORY_LAP_FIELDS = (
        'start_time',
        'total_distance',
        'total_elapsed_time'
    )

    OPTIONAL_LAP_FIELDS = (
        'total_calories'
    )

    LATLON_TO_DECIMAL = (2 ** 32) / 360

    def __init__(self, *args, **kwargs):
        self._metadata: Dict[str, Union[str, datetime, timedelta, Optional[str]]] = {
            'name': None,
            'description': None
        }
        self._points_data = []
        self._laps_data = []
        super().__init__(*args, **kwargs)

    def _add_point(
            self,
            lat: Optional[float],
            lon: Optional[float],
            elev: Optional[float],
            timestamp: Optional[datetime],
            heart_rate: Optional[int],
            cadence: Optional[int],
            speed: Optional[float]
    ):
        data = {
            'point_no': self._get_point_no(),
            'track_no': 0,
            'segment_no': 0,
            'latitude': None,
            'longitude': None,
            'elevation': elev,
            'time': timestamp,
            'hr': heart_rate,
            'cadence': cadence,
            'lap': self._lap,
            'kmph': self.convert_speed(speed)
        }

        # https://gis.stackexchange.com/questions/122186/convert-garmin-or-iphone-weird-gps-coordinates
        if (lat is not None):
            data['latitude'] = lat / self.LATLON_TO_DECIMAL
        if (lon is not None):
            data['longitude'] = lon / self.LATLON_TO_DECIMAL

        self.handle_backfill(data, self._points_data, lat, lon)

    def _parse_record(self, frame: fitdecode.FitDataMessage):
        """Parse a FitDataMessage of type `record`, which contains
        information about a single point.
        """
        if frame.has_field('timestamp') and frame.has_field('altitude'):
            self._add_point(
                frame.get_value('position_lat', fallback=None),
                frame.get_value('position_long', fallback=None),
                frame.get_value('altitude'),
                frame.get_value('timestamp'),
                frame.get_value('heart_rate', fallback=None),
                frame.get_value('cadence', fallback=None),
                frame.get_value('speed', fallback=None)
            )

    def _parse_lap(self, frame: fitdecode.FitDataMessage):
        """Parse a FitDataMessage of type `lap`, which contains
        information about a lap.
        """
        self._laps_data.append({
            'lap_no': self._get_lap_no(),
            'start_time': frame.get_value('start_time'),
            'distance': frame.get_value('total_distance'),
            'duration': timedelta(seconds=frame.get_value('total_elapsed_time')),
            'calories': frame.get_value('total_calories', fallback=None)
        })

    def _parse_session(self, frame: fitdecode.FitDataMessage):
        """Parse a FitDataMessage of type `session`, which contains
        information about an activity.
        """
        self._metadata['date_time'] = frame.get_value('start_time')
        self._metadata['activity_type'] = self.GARMIN_TYPES.get(frame.get_value('sport'))
        if frame.has_field('total_elapsed_time'):
            self._metadata['duration'] = timedelta(seconds=frame.get_value('total_elapsed_time'))
        if frame.has_field('total_distance'):
            self._metadata['distance_2d_km'] = frame.get_value('total_distance') / 1000

    def _parse(self, fpath: str):
        with fitdecode.FitReader(fpath) as fit:
            for frame in fit:
                if isinstance(frame, fitdecode.FitDataMessage):
                    if frame.name == 'record':
                        self._parse_record(frame)
                    elif frame.name == 'lap':
                        self._parse_lap(frame)
                    elif frame.name == 'session':
                        self._parse_session(frame)

        self._points = self.infer_points_data(pd.DataFrame(self._points_data, columns=self.INITIAL_COL_NAMES_POINTS))
        self._laps = pd.DataFrame(self._laps_data, columns=self.INITIAL_COL_NAMES_LAPS)

    @property
    def metadata(self) -> dict:
        return self._metadata

    @property
    def activity_type(self) -> str:
        return self._metadata['activity_type']

    @property
    def points(self) -> pd.DataFrame:
        return self._points

    @property
    def laps(self) -> pd.DataFrame:
        return self._laps

    @property
    def date_time(self) -> datetime:
        return self._metadata['date_time']


PARSERS = {
    '.fit': FITParser,
    '.gpx': GPXParser
}


def parser_factory(fpath: str, config: Config) -> BaseParser:
    _, ext = os.path.splitext(fpath.lower())
    try:
        parser = PARSERS[ext]
    except KeyError:
        raise ValueError(f'No suitable parser found for file "{fpath}".')
    return parser(fpath, config)
